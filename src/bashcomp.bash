# Bash completion for chopper-managed aliases.
# Generated by: chopper --bashcomp
# Source this file in your .bashrc or save it to a persistent location:
#   source <(chopper --bashcomp)
#   # or:
#   chopper --bashcomp > ~/.local/share/bash-completion/completions/chopper
#
# Design: uses the decorator/proxy pattern (like sudo/env in bash-completion)
# to delegate completion to the underlying command's native completer. Queries
# chopper introspection builtins for alias state and caches results per-session.

# Guard: only define once per shell session.
if declare -F _chopper_complete &>/dev/null; then
    return 0 2>/dev/null || true
fi

# ---------------------------------------------------------------------------
# Session cache
# ---------------------------------------------------------------------------
# Associative arrays for per-alias caching.
# _chopper_cache_exec[alias] = resolved exec path
# _chopper_cache_mode[alias] = disabled|passthrough|custom|normal
declare -gA _chopper_cache_exec=()
declare -gA _chopper_cache_mode=()

# Bust the session cache (call this to pick up config changes mid-session).
_chopper_cache_bust() {
    _chopper_cache_exec=()
    _chopper_cache_mode=()
}

# ---------------------------------------------------------------------------
# Internal: query chopper for alias metadata (with caching)
# ---------------------------------------------------------------------------
_chopper_resolve() {
    local alias="$1"

    # Return cached values if available.
    if [[ -n "${_chopper_cache_mode[$alias]+set}" ]]; then
        return 0
    fi

    # Guard: is chopper available?
    if ! type -P chopper &>/dev/null; then
        _chopper_cache_mode[$alias]="normal"
        _chopper_cache_exec[$alias]=""
        return 0
    fi

    # Query mode. If the query fails, default to normal.
    local mode
    mode=$(chopper --print-bashcomp-mode "$alias" 2>/dev/null) || mode="normal"
    _chopper_cache_mode[$alias]="$mode"

    # For disabled mode, skip the exec lookup entirely.
    if [[ "$mode" == "disabled" ]]; then
        _chopper_cache_exec[$alias]=""
        return 0
    fi

    # Query exec path.
    local exec_path
    exec_path=$(chopper --print-exec "$alias" 2>/dev/null) || exec_path=""
    _chopper_cache_exec[$alias]="$exec_path"
}

# ---------------------------------------------------------------------------
# Internal: try to load the underlying command's completer
# ---------------------------------------------------------------------------
_chopper_load_underlying_completer() {
    local cmd_basename="$1"

    # If bash-completion's _completion_loader is available, use it.
    if declare -F _completion_loader &>/dev/null; then
        _completion_loader "$cmd_basename" 2>/dev/null
        return
    fi

    # Fallback: try sourcing from common completion directories.
    local comp_dir
    local comp_file
    for comp_dir in \
        "${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions" \
        "/usr/share/bash-completion/completions" \
        "/etc/bash_completion.d"; do
        for comp_file in \
            "$comp_dir/$cmd_basename" \
            "$comp_dir/$cmd_basename.bash" \
            "$comp_dir/_$cmd_basename"; do
            if [[ -f "$comp_file" ]]; then
                # shellcheck disable=SC1090
                source "$comp_file" 2>/dev/null
                return
            fi
        done
    done
}

# ---------------------------------------------------------------------------
# Internal: find the registered completion function for a command
# ---------------------------------------------------------------------------
_chopper_find_compfunc() {
    local cmd="$1"
    local compspec
    compspec=$(complete -p "$cmd" 2>/dev/null) || return 1
    # Extract the function name from "complete -F <funcname> ..."
    local func
    func=$(printf '%s\n' "$compspec" | sed -n 's/.*-F \([^ ]*\).*/\1/p')
    if [[ -n "$func" ]] && declare -F "$func" &>/dev/null; then
        printf '%s\n' "$func"
        return 0
    fi
    return 1
}

# ---------------------------------------------------------------------------
# Main completion function
# ---------------------------------------------------------------------------
_chopper_complete() {
    local alias_name="${COMP_WORDS[0]}"
    # Strip path prefix if present (e.g., /usr/local/bin/myalias -> myalias)
    alias_name="${alias_name##*/}"

    # Resolve alias metadata (cached).
    _chopper_resolve "$alias_name"

    local mode="${_chopper_cache_mode[$alias_name]}"
    local target="${_chopper_cache_exec[$alias_name]}"

    # ----- disabled mode: return immediately, no side effects -----
    if [[ "$mode" == "disabled" ]]; then
        COMPREPLY=()
        return 0
    fi

    # ----- custom mode: source and call custom completion script -----
    if [[ "$mode" == "custom" ]]; then
        # Custom scripts define _chopper_bashcomp_<alias>() and are sourced
        # via the bashcomp.script config field. For now, since we cannot
        # query the custom script path from the bash side without another
        # introspection call, we check if the function already exists
        # (it may have been sourced previously) and fall through to normal
        # delegation if not.
        local custom_func="_chopper_bashcomp_${alias_name//[^a-zA-Z0-9_]/_}"
        if declare -F "$custom_func" &>/dev/null; then
            "$custom_func"
            return
        fi
        # Fall through to normal delegation if custom func not loaded.
    fi

    # ----- passthrough / normal: delegate to underlying completer -----
    if [[ -z "$target" ]]; then
        # No target resolved; fall back to default completion.
        if declare -F _comp_compgen_filedir &>/dev/null; then
            _comp_compgen_filedir
        elif declare -F _filedir &>/dev/null; then
            _filedir
        else
            COMPREPLY=($(compgen -o default -- "${COMP_WORDS[$COMP_CWORD]}"))
        fi
        return 0
    fi

    local target_basename="${target##*/}"

    # Save original completion state.
    local _chopper_orig_words=("${COMP_WORDS[@]}")
    local _chopper_orig_cword="$COMP_CWORD"
    local _chopper_orig_line="$COMP_LINE"
    local _chopper_orig_point="$COMP_POINT"

    # Rewrite completion context to reference the underlying command.
    COMP_WORDS[0]="$target_basename"
    COMP_LINE="${target_basename}${COMP_LINE#"${_chopper_orig_words[0]}"}"
    COMP_POINT=$(( COMP_POINT - ${#_chopper_orig_words[0]} + ${#target_basename} ))

    # Ensure the underlying command's completer is loaded.
    local underlying_func
    underlying_func=$(_chopper_find_compfunc "$target_basename" 2>/dev/null) || true

    if [[ -z "$underlying_func" ]]; then
        _chopper_load_underlying_completer "$target_basename"
        underlying_func=$(_chopper_find_compfunc "$target_basename" 2>/dev/null) || true
    fi

    if [[ -n "$underlying_func" ]]; then
        # Call the underlying completer with rewritten context.
        "$underlying_func"
    elif declare -F _command_offset &>/dev/null; then
        # bash-completion available but no specific completer; use generic.
        _command_offset 0
    else
        # No bash-completion framework; fall back to default.
        COMPREPLY=($(compgen -o default -- "${COMP_WORDS[$COMP_CWORD]}"))
    fi

    # Restore original completion state.
    COMP_WORDS=("${_chopper_orig_words[@]}")
    COMP_CWORD="$_chopper_orig_cword"
    COMP_LINE="$_chopper_orig_line"
    COMP_POINT="$_chopper_orig_point"
}

# ---------------------------------------------------------------------------
# Register completion for all known chopper aliases
# ---------------------------------------------------------------------------
_chopper_register_aliases() {
    # Guard: is chopper available?
    if ! type -P chopper &>/dev/null; then
        return 0
    fi

    local alias_name
    while IFS= read -r alias_name; do
        [[ -z "$alias_name" ]] && continue
        complete -F _chopper_complete -o bashdefault -o default "$alias_name"
    done < <(chopper --list-aliases 2>/dev/null)
}

# ---------------------------------------------------------------------------
# Project per-alias shims into BASH_COMPLETION_USER_DIR
# ---------------------------------------------------------------------------
_chopper_project_shims() {
    local comp_dir="${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions"

    # Only project if the directory exists and is writable.
    if [[ ! -d "$comp_dir" ]] || [[ ! -w "$comp_dir" ]]; then
        return 0
    fi

    # Guard: is chopper available?
    if ! type -P chopper &>/dev/null; then
        return 0
    fi

    local -A current_aliases=()
    local alias_name
    while IFS= read -r alias_name; do
        [[ -z "$alias_name" ]] && continue
        current_aliases[$alias_name]=1

        local shim_file="$comp_dir/$alias_name"
        # Only write if the shim does not exist or was generated by us.
        if [[ -f "$shim_file" ]]; then
            # Check if it's one of ours by looking for the marker comment.
            if ! head -n1 "$shim_file" 2>/dev/null | grep -q 'Auto-generated by chopper'; then
                continue
            fi
        fi
        printf '# Auto-generated by chopper --bashcomp. Safe to delete.\ncomplete -F _chopper_complete -o bashdefault -o default %s\n' "$alias_name" > "$shim_file" 2>/dev/null
    done < <(chopper --list-aliases 2>/dev/null)

    # Clean up stale shims (generated by us but alias no longer listed).
    local shim
    for shim in "$comp_dir"/*; do
        [[ -f "$shim" ]] || continue
        local basename="${shim##*/}"
        if [[ -z "${current_aliases[$basename]+set}" ]]; then
            if head -n1 "$shim" 2>/dev/null | grep -q 'Auto-generated by chopper'; then
                rm -f "$shim" 2>/dev/null
            fi
        fi
    done
}

# ---------------------------------------------------------------------------
# Register completions for chopper itself (direct invocation mode)
# ---------------------------------------------------------------------------
_chopper_complete_direct() {
    local cur="${COMP_WORDS[$COMP_CWORD]}"

    if (( COMP_CWORD == 1 )); then
        # First arg: complete built-in flags or alias names.
        local builtins="--help --version --print-config-dir --print-cache-dir --bashcomp --list-aliases --print-exec --print-bashcomp-mode"
        local aliases
        aliases=$(chopper --list-aliases 2>/dev/null) || aliases=""
        COMPREPLY=($(compgen -W "$builtins $aliases" -- "$cur"))
        return 0
    fi

    local flag="${COMP_WORDS[1]}"
    if (( COMP_CWORD == 2 )) && [[ "$flag" == "--print-exec" || "$flag" == "--print-bashcomp-mode" ]]; then
        # Second arg for these flags: complete alias names.
        local aliases
        aliases=$(chopper --list-aliases 2>/dev/null) || aliases=""
        COMPREPLY=($(compgen -W "$aliases" -- "$cur"))
        return 0
    fi

    # For `chopper <alias> [args...]`, delegate to the alias's completion.
    if (( COMP_CWORD >= 2 )); then
        local alias_name="${COMP_WORDS[1]}"
        # Temporarily rewrite as if the alias was invoked directly.
        local _chopper_orig_words=("${COMP_WORDS[@]}")
        local _chopper_orig_cword="$COMP_CWORD"
        local _chopper_orig_line="$COMP_LINE"
        local _chopper_orig_point="$COMP_POINT"

        # Remove "chopper" from the front.
        COMP_WORDS=("${COMP_WORDS[@]:1}")
        COMP_CWORD=$(( COMP_CWORD - 1 ))
        local chopper_prefix="${_chopper_orig_words[0]} "
        COMP_LINE="${COMP_LINE#"$chopper_prefix"}"
        COMP_POINT=$(( COMP_POINT - ${#chopper_prefix} ))

        _chopper_complete

        COMP_WORDS=("${_chopper_orig_words[@]}")
        COMP_CWORD="$_chopper_orig_cword"
        COMP_LINE="$_chopper_orig_line"
        COMP_POINT="$_chopper_orig_point"
        return 0
    fi
}

# ---------------------------------------------------------------------------
# Initialization
# ---------------------------------------------------------------------------

# Register completion for direct chopper invocations.
complete -F _chopper_complete_direct -o bashdefault -o default chopper

# Register completion for all known aliases.
_chopper_register_aliases

# Project shims into BASH_COMPLETION_USER_DIR (best-effort).
_chopper_project_shims
